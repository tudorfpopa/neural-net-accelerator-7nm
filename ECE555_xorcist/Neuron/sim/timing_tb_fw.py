#!/usr/bin/env python3
"""
Timing Testbench for Ternary Neuron with Fixed Weights
Tests all input combinations for each fixed-weight configuration
"""

from pathlib import Path
import subprocess
import re
from itertools import product
import glob

def ternary_to_bits(value, vdd=0.9):
    """Convert ternary value to dual-rail encoding voltages"""
    if value == -1:
        return (vdd, vdd)  # bit0=VDD, bit1=VDD
    elif value == 0:
        return (0, 0)      # bit0=0, bit1=0
    elif value == 1:
        return (vdd, 0)    # bit0=VDD, bit1=0
    else:
        raise ValueError(f"Invalid ternary value: {value}")

def cleanup_test_files(test_id):
    """Remove all test files generated by verification"""
    patterns = [
        f'timing_test_{test_id}.sp',
        f'timing_test_{test_id}.lis',
        f'timing_test_{test_id}.ic*',
        f'timing_test_{test_id}.st0',
        f'timing_test_{test_id}.tr0',
        f'timing_test_{test_id}.pa0',
        f'timing_test_{test_id}.mt0',
        f'timing_test_{test_id}.ms0',
        f'timing_test_{test_id}.sw0',
        f'timing_test_{test_id}.*'
    ]
    
    for pattern in patterns:
        for f in glob.glob(pattern):
            try:
                Path(f).unlink()
            except:
                pass

def golden_model(x0, x1, w0, w1, w2):
    """Calculate expected output"""
    weighted_sum = x0 * w0 + x1 * w1 + w2
    relu_out = max(0, weighted_sum)
    return min(7, relu_out)

def generate_timing_testbench(tc, test_id, netlist='Neuron_submod.pex.netlist', vdd=0.9):
    """
    Generate timing testbench with fixed weights and cycling inputs
    
    tc structure:
    {
        'w0': weight0,
        'w1': weight1,
        'w2': weight2 (bias),
        'input_sequence': [
            {'x0': val, 'x1': val, 'expected': val},
            {'x0': val, 'x1': val, 'expected': val},
            ...
        ]
    }
    """
    
    # Fixed weights for entire test
    w0_0, w0_1 = ternary_to_bits(tc['w0'], vdd)
    w1_0, w1_1 = ternary_to_bits(tc['w1'], vdd)
    w2_0, w2_1 = ternary_to_bits(tc['w2'], vdd)
    
    # Build PULSE statements for inputs that cycle through sequence
    # Each input pair gets 500ns, transitions at 5ns with 25ps rise/fall
    input_sequence = tc['input_sequence']
    num_inputs = len(input_sequence)
    
    # Time per input: 500ns
    time_per_input = 500  # nanoseconds
    total_time = num_inputs * time_per_input
    
    # Generate PULSE statements for cycling inputs
    x0_pulses = []
    x1_pulses = []
    
    for i, inp in enumerate(input_sequence):
        start_time = i * time_per_input
        transition_time = start_time + 5  # Transition 5ns into each period
        
        x0_0_val, x0_1_val = ternary_to_bits(inp['x0'], vdd)
        x1_0_val, x1_1_val = ternary_to_bits(inp['x1'], vdd)
        
        # Previous values (for smooth transitions)
        if i == 0:
            x0_0_prev, x0_1_prev = (0, 0)
            x1_0_prev, x1_1_prev = (0, 0)
        else:
            x0_0_prev, x0_1_prev = ternary_to_bits(input_sequence[i-1]['x0'], vdd)
            x1_0_prev, x1_1_prev = ternary_to_bits(input_sequence[i-1]['x1'], vdd)
        
        # Only add PULSE if value changes
        if i == 0 or x0_0_val != x0_0_prev:
            x0_pulses.append(f"PULSE({x0_0_prev} {x0_0_val} {transition_time}n 25p 25p {time_per_input-10}n {total_time*2}n)")
        if i == 0 or x0_1_val != x0_1_prev:
            x0_pulses.append(f"PULSE({x0_1_prev} {x0_1_val} {transition_time}n 25p 25p {time_per_input-10}n {total_time*2}n)")
        if i == 0 or x1_0_val != x1_0_prev:
            x1_pulses.append(f"PULSE({x1_0_prev} {x1_0_val} {transition_time}n 25p 25p {time_per_input-10}n {total_time*2}n)")
        if i == 0 or x1_1_val != x1_1_prev:
            x1_pulses.append(f"PULSE({x1_1_prev} {x1_1_val} {transition_time}n 25p 25p {time_per_input-10}n {total_time*2}n)")
    
    # For simplicity, use PWL (piecewise linear) for inputs
    # Build PWL points
    x0_0_pwl = ["0 0"]
    x0_1_pwl = ["0 0"]
    x1_0_pwl = ["0 0"]
    x1_1_pwl = ["0 0"]
    
    for i, inp in enumerate(input_sequence):
        t_start = i * time_per_input
        t_transition = t_start + 5
        
        x0_0_val, x0_1_val = ternary_to_bits(inp['x0'], vdd)
        x1_0_val, x1_1_val = ternary_to_bits(inp['x1'], vdd)
        
        # Add transition point and settle point
        x0_0_pwl.append(f"{t_transition-0.025}n {x0_0_pwl[-1].split()[1]}")  # Hold previous
        x0_0_pwl.append(f"{t_transition+0.025}n {x0_0_val}")  # Transition (25ps)
        x0_0_pwl.append(f"{(i+1)*time_per_input-1}n {x0_0_val}")  # Hold new value
        
        x0_1_pwl.append(f"{t_transition-0.025}n {x0_1_pwl[-1].split()[1]}")
        x0_1_pwl.append(f"{t_transition+0.025}n {x0_1_val}")
        x0_1_pwl.append(f"{(i+1)*time_per_input-1}n {x0_1_val}")
        
        x1_0_pwl.append(f"{t_transition-0.025}n {x1_0_pwl[-1].split()[1]}")
        x1_0_pwl.append(f"{t_transition+0.025}n {x1_0_val}")
        x1_0_pwl.append(f"{(i+1)*time_per_input-1}n {x1_0_val}")
        
        x1_1_pwl.append(f"{t_transition-0.025}n {x1_1_pwl[-1].split()[1]}")
        x1_1_pwl.append(f"{t_transition+0.025}n {x1_1_val}")
        x1_1_pwl.append(f"{(i+1)*time_per_input-1}n {x1_1_val}")
    
    testbench = f"""** Ternary Neuron Timing Test {test_id}
** Fixed weights: w0={tc['w0']}, w1={tc['w1']}, w2={tc['w2']}
** Input sequence: {num_inputs} different input combinations
** Each input held for {time_per_input}ns, transition time 25ps

.TEMP 25.0
.OPTION ARTIST=2 INGOLD=2 PARHIER=LOCAL PSF=2 POST=2 ACCURATE NUMDGT=8 CASE=INSENSITIVE

** Include PDK models
.INCLUDE "/cae/apps/data/asap7PDK-2022/asap7PDK_r1p7/models/hspice/7nm_TT_160803.pm"

** Include neuron netlist
.INCLUDE "{netlist}"

** Define INV subcircuit for FO4 loads
.subckt INV in out vdd vss
mn0 out in vss vss nmos_rvt w=54e-9 l=20e-9 nfin=2
mp1 out in vdd vdd pmos_rvt w=81e-9 l=20e-9 nfin=3
.ends INV

** Supply voltages
vvdd vdd 0 DC {vdd}
vvss vss 0 DC 0

** Instantiate neuron
xneuron vss x_1<0> x_1<1> x_0<0> x_0<1> vdd w_10<0> w_00<0> w_10<1> w_00<1> w_20<1> w_20<0> z_0<1> z_0<0> z_0<2> Neuron_submod

** Fixed weights (DC)
vw00_0 w_00<0> 0 DC {w0_0}
vw00_1 w_00<1> 0 DC {w0_1}
vw10_0 w_10<0> 0 DC {w1_0}
vw10_1 w_10<1> 0 DC {w1_1}
vw20_0 w_20<0> 0 DC {w2_0}
vw20_1 w_20<1> 0 DC {w2_1}

** Cycling inputs (PWL waveforms)
vx0_0 x_0<0> 0 PWL {' '.join(x0_0_pwl)}
vx0_1 x_0<1> 0 PWL {' '.join(x0_1_pwl)}
vx1_0 x_1<0> 0 PWL {' '.join(x1_0_pwl)}
vx1_1 x_1<1> 0 PWL {' '.join(x1_1_pwl)}

** Output loads - FO4
xinv_z0_0_0 z_0<0> z0_0_inv0 vdd vss INV
xinv_z0_0_1 z_0<0> z0_0_inv1 vdd vss INV
xinv_z0_0_2 z_0<0> z0_0_inv2 vdd vss INV
xinv_z0_0_3 z_0<0> z0_0_inv3 vdd vss INV
xinv_z0_1_0 z_0<1> z0_1_inv0 vdd vss INV
xinv_z0_1_1 z_0<1> z0_1_inv1 vdd vss INV
xinv_z0_1_2 z_0<1> z0_1_inv2 vdd vss INV
xinv_z0_1_3 z_0<1> z0_1_inv3 vdd vss INV
xinv_z0_2_0 z_0<2> z0_2_inv0 vdd vss INV
xinv_z0_2_1 z_0<2> z0_2_inv1 vdd vss INV
xinv_z0_2_2 z_0<2> z0_2_inv2 vdd vss INV
xinv_z0_2_3 z_0<2> z0_2_inv3 vdd vss INV

** Transient analysis
.TRAN 1p {total_time}n

** Measurements for each input in sequence
"""
    
    # Add measurements for each input period
    for i, inp in enumerate(input_sequence):
        measure_time = (i+1) * time_per_input - 10  # Measure 10ns before next transition
        
        testbench += f"""
** Input {i}: x0={inp['x0']}, x1={inp['x1']}, expected={inp['expected']}
.MEAS TRAN v_z0_0_inp{i} FIND v(z_0<0>) AT={measure_time}n
.MEAS TRAN v_z0_1_inp{i} FIND v(z_0<1>) AT={measure_time}n
.MEAS TRAN v_z0_2_inp{i} FIND v(z_0<2>) AT={measure_time}n
"""
    
    # Add propagation delay measurements for all transitions
    testbench += f"""
** Propagation delay measurements for all transitions
"""
    for i in range(len(input_sequence)):
        transition_time = i * time_per_input + 5  # Each transition happens at 5ns into period
        cross_num = i + 1  # CROSS index starts at 1
        
        testbench += f"""
** Transition {i} (at {transition_time}ns)
.MEAS TRAN t_in_{i} WHEN v(x_0<1>)={vdd/2} CROSS={cross_num}
.MEAS TRAN t_out0_{i} WHEN v(z_0<0>)={vdd/2} CROSS={cross_num}
.MEAS TRAN t_out1_{i} WHEN v(z_0<1>)={vdd/2} CROSS={cross_num}
.MEAS TRAN t_out2_{i} WHEN v(z_0<2>)={vdd/2} CROSS={cross_num}
.MEAS TRAN tpd_0_{i} PARAM='t_out0_{i}-t_in_{i}'
.MEAS TRAN tpd_1_{i} PARAM='t_out1_{i}-t_in_{i}'
.MEAS TRAN tpd_2_{i} PARAM='t_out2_{i}-t_in_{i}'
"""
    
    testbench += f"""
** Power
.MEAS TRAN power_avg AVG POWER FROM={time_per_input}n TO={total_time}n

.END
"""
    
    tb_path = Path(f'timing_test_{test_id}.sp')
    with open(tb_path, 'w') as f:
        f.write(testbench)
    
    return tb_path

meas_base_names = ['v_z0_0_inp', 'v_z0_1_inp', 'v_z0_2_inp']

def parse_measurements(mt0_file, num_inputs, vdd=0.9):
    """Parse measurements for all inputs in sequence"""
    if not mt0_file.exists():
        return None
    
    with open(mt0_file, 'r') as f:
        content = f.read()
    
    results = {'inputs': [], 'tpds': []}
    
    # Parse measurements for each input
    for i in range(num_inputs):
        input_result = {}
        for base in ['v_z0_0_inp', 'v_z0_1_inp', 'v_z0_2_inp']:
            meas_name = f'{base}{i}'
            match = re.search(rf'{meas_name}\s+([\d.e+-]+|failed)', content)
            if match:
                val = match.group(1)
                input_result[base] = None if val == 'failed' else float(val)
        
        # Convert to output value
        if all(k in input_result for k in ['v_z0_0_inp', 'v_z0_1_inp', 'v_z0_2_inp']):
            bit0 = 1 if input_result['v_z0_0_inp'] > vdd/2 else 0
            bit1 = 1 if input_result['v_z0_1_inp'] > vdd/2 else 0
            bit2 = 1 if input_result['v_z0_2_inp'] > vdd/2 else 0
            input_result['output'] = bit2*4 + bit1*2 + bit0
        
        results['inputs'].append(input_result)
    
    # Parse all propagation delays for all transitions
    all_tpds = []
    for i in range(num_inputs):
        for bit in [0, 1, 2]:
            meas_name = f'tpd_{bit}_{i}'
            match = re.search(rf'{meas_name}\s+([\d.e+-]+|failed)', content)
            if match:
                val = match.group(1)
                if val != 'failed':
                    tpd_val = float(val)
                    all_tpds.append(tpd_val)
                    results['tpds'].append({
                        'transition': i,
                        'output_bit': bit,
                        'tpd': tpd_val
                    })
    
    # Find maximum propagation delay across all transitions
    if all_tpds:
        results['tpd_max'] = max(all_tpds)
        results['tpd_avg'] = sum(all_tpds) / len(all_tpds)
    else:
        results['tpd_max'] = None
        results['tpd_avg'] = None
    
    # Parse power
    match = re.search(r'power_avg\s+([\d.e+-]+|failed)', content)
    if match:
        val = match.group(1)
        results['power'] = None if val == 'failed' else float(val)
    
    return results

def run_test_case(tc, test_id, netlist='Neuron_submod.pex.netlist'):
    """Run a single test case"""
    tb_path = generate_timing_testbench(tc, test_id, netlist)
    
    try:
        result = subprocess.run(
            ['hspice', str(tb_path)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=600,  # Longer timeout for multiple inputs
            text=True
        )
        
        if result.returncode != 0:
            return None
        
        mt0_path = tb_path.with_suffix('.mt0')
        num_inputs = len(tc['input_sequence'])
        return parse_measurements(mt0_path, num_inputs)
        
    except Exception as e:
        print(f"  Error: {e}")
        return None

def generate_test_cases():
    """Generate all fixed-weight configurations with all input combinations"""
    test_cases = []
    test_id = 0
    
    print(f"\n{'='*70}")
    print(f"Generating Test Cases: Fixed Weights with Cycling Inputs")
    print(f"{'='*70}")
    
    # All possible weight combinations (3^3 = 27)
    for w0, w1, w2 in product([-1, 0, 1], repeat=3):
        # All possible input combinations (3^2 = 9)
        input_sequence = []
        for x0, x1 in product([-1, 0, 1], repeat=2):
            expected = golden_model(x0, x1, w0, w1, w2)
            input_sequence.append({
                'x0': x0,
                'x1': x1,
                'expected': expected
            })
        
        test_cases.append({
            'id': test_id,
            'w0': w0,
            'w1': w1,
            'w2': w2,
            'input_sequence': input_sequence
        })
        test_id += 1
    
    print(f"Generated {len(test_cases)} weight configurations")
    print(f"Each with {len(test_cases[0]['input_sequence'])} input combinations")
    print(f"Total measurements: {len(test_cases) * len(test_cases[0]['input_sequence'])}")
    print(f"{'='*70}\n")
    
    return test_cases

if __name__ == '__main__':
    import sys
    
    print("="*70)
    print("Ternary Neuron Timing Analysis - Fixed Weights, Cycling Inputs")
    print("="*70)
    print()
    
    pex_netlist = 'Neuron_submod.pex.netlist'
    if not Path(pex_netlist).exists():
        print(f"❌ Error: {pex_netlist} not found!")
        sys.exit(1)
    
    test_cases = generate_test_cases()
    
    print(f"Running {len(test_cases)} test cases...")
    print()
    
    all_results = []
    max_tpd_global = 0
    
    for tc in test_cases:
        print(f"\nTest {tc['id']}: Weights w0={tc['w0']:+d}, w1={tc['w1']:+d}, w2={tc['w2']:+d}")
        print(f"  Testing {len(tc['input_sequence'])} input combinations...")
        
        measurements = run_test_case(tc, tc['id'], pex_netlist)
        
        if measurements and 'inputs' in measurements:
            # Check all inputs
            all_passed = True
            for i, (inp_meas, inp_expected) in enumerate(zip(measurements['inputs'], tc['input_sequence'])):
                actual = inp_meas.get('output', 'N/A')
                expected = inp_expected['expected']
                passed = (actual == expected)
                
                if not passed:
                    all_passed = False
                    print(f"    Input {i} [x0={inp_expected['x0']:+d}, x1={inp_expected['x1']:+d}]: " +
                          f"Expected={expected}, Actual={actual} ❌ FAIL")
            
            tpd_max = measurements.get('tpd_max', 0) or 0
            tpd_avg = measurements.get('tpd_avg', 0) or 0
            max_tpd_global = max(max_tpd_global, tpd_max)
            
            status = "✅ PASS" if all_passed else "❌ FAIL"
            print(f"  Status: {status}")
            print(f"  tpd_max={tpd_max*1e9:.3f}ns, tpd_avg={tpd_avg*1e9:.3f}ns")
            print(f"  Global max tpd={max_tpd_global*1e9:.3f}ns")
            print(f"  Power={measurements.get('power', 0)*1e9:.3f}nW")
            
            all_results.append({
                **tc,
                'measurements': measurements,
                'passed': all_passed
            })
        else:
            print(f"  ❌ Simulation failed")
            all_results.append({**tc, 'passed': False})
        
        # Cleanup after each test
        cleanup_test_files(tc['id'])
    
    # Summary
    print("\n" + "="*70)
    print("Summary")
    print("="*70)
    passed = sum(1 for r in all_results if r.get('passed', False))
    print(f"Tests passed: {passed}/{len(all_results)}")
    print(f"Maximum propagation delay (across all tests): {max_tpd_global*1e9:.3f}ns")
    print("="*70)