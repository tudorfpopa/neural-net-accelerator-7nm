#!/usr/bin/env python3
"""
Simple Timing Testbench for Ternary Neuron
Tests multiple cases (random + edge cases) and reports propagation delays
"""

from pathlib import Path
import subprocess
import re
from itertools import product
import glob

def ternary_to_bits(value, vdd=0.9):
    """Convert ternary value to dual-rail encoding voltages
    Returns (bit0, bit1) in correct order for vx_0, vx_1 assignment
    """
    if value == -1:
        return (vdd, vdd)  # bit0=VDD, bit1=VDD
    elif value == 0:
        return (0, 0)      # bit0=0, bit1=0
    elif value == 1:
        return (vdd, 0)    # bit0=0, bit1=VDD (was backwards!)
    else:
        raise ValueError(f"Invalid ternary value: {value}")
    
def cleanup_test_files(test_id):
    """Remove all test files generated by verification"""
    
    # All possible test file patterns
    patterns = [
        f'timing_test_{test_id}.sp',
        f'timing_test_{test_id}.lis',
        f'timing_test_{test_id}.ic',
        f'timing_test_{test_id}.ic0',
        f'timing_test_{test_id}.st0',
        f'timing_test_{test_id}.tr0',
        f'timing_test_{test_id}.pa0',
        f'timing_test_{test_id}.mt0',
        f'timing_test_{test_id}.ms0',
        f'timing_test_{test_id}.sw0',
        f'timing_test_{test_id}.ac0',
        f'timing_test_{test_id}.measure',
        f'timing_test_{test_id}.log',
        f'timing_test_{test_id}.out'
    ]
    
    all_files = []
    for pattern in patterns:
        all_files.extend(glob.glob(pattern))
    
    for f in all_files:
        try:
            Path(f).unlink()
        except Exception as e:
            print(f"⚠️  Could not delete {f}: {e}")

def golden_model(x0, x1, w0, w1, w2):
    """Calculate expected output"""
    weighted_sum = x0 * w0 + x1 * w1 + w2
    relu_out = max(0, weighted_sum)
    return min(7, relu_out)

def generate_timing_testbench(tc, test_id, netlist='Neuron_submod.pex.netlist', vdd=0.9):
    """Generate timing testbench for a single test case"""
    
    # End values (test case values)
    x0_0_end, x0_1_end = ternary_to_bits(tc['x0'], vdd)
    x1_0_end, x1_1_end = ternary_to_bits(tc['x1'], vdd)
    w0_0_end, w0_1_end = ternary_to_bits(tc['w0'], vdd)
    w1_0_end, w1_1_end = ternary_to_bits(tc['w1'], vdd)
    w2_0_end, w2_1_end = ternary_to_bits(tc['w2'], vdd)

        # Start values (all zeros)
    x0_0_start = vdd if x0_0_end == 0 else 0
    x0_1_start = vdd if x0_1_end == 0 else 0
    x1_0_start = vdd if x1_0_end == 0 else 0
    x1_1_start = vdd if x1_1_end == 0 else 0
    w0_0_start = w0_0_end
    w0_1_start = w0_1_end
    w1_0_start = w1_0_end
    w1_1_start = w1_1_end
    w2_0_start = w2_0_end
    w2_1_start = w2_1_end
    
    testbench = f"""** Ternary Neuron Timing Test {test_id}
** Test: x0={tc['x0']}, x1={tc['x1']}, w0={tc['w0']}, w1={tc['w1']}, w2={tc['w2']}
** Expected output: {tc['expected']}
** Uses 25ps rise/fall times per project specs

.TEMP 25.0
.OPTION ARTIST=2 INGOLD=2 PARHIER=LOCAL PSF=2 POST=2 ACCURATE NUMDGT=8 CASE=INSENSITIVE

** Include PDK models
.INCLUDE "/cae/apps/data/asap7PDK-2022/asap7PDK_r1p7/models/hspice/7nm_TT_160803.pm"

** Include neuron netlist
.INCLUDE "{netlist}"

** Define INV subcircuit for FO4 loads
.subckt INV in out vdd vss
mn0 out in vss vss nmos_rvt w=54e-9 l=20e-9 nfin=2
mp1 out in vdd vdd pmos_rvt w=81e-9 l=20e-9 nfin=3
.ends INV

** Supply voltages
vvdd vdd 0 DC {vdd}
vvss vss 0 DC 0

** Instantiate neuron (PEX netlist defines it as a subcircuit)
xneuron vss vdd w_10<0> x_1<1> x_0<1> w_00<0> x_1<0> x_0<0> w_10<1> w_00<1> w_20<1> w_20<0> z_0<0> z_0<1> z_0<2> Neuron_submod

** Input stimulus: transition at 5ns with 25ps rise/fall
vx0_0 x_0<0> 0 PULSE({x0_0_start} {x0_0_end} 10n 25p 25p 500n 1000n)
vx0_1 x_0<1> 0 PULSE({x0_1_start} {x0_1_end} 10n 25p 25p 500n 1000n)
vx1_0 x_1<0> 0 PULSE({x1_0_start} {x1_0_end} 10n 25p 25p 500n 1000n)
vx1_1 x_1<1> 0 PULSE({x1_1_start} {x1_1_end} 10n 25p 25p 500n 1000n)
vw00_0 w_00<0> 0 PULSE({w0_0_start} {w0_0_end} 5n 25p 25p 500n 1000n)
vw00_1 w_00<1> 0 PULSE({w0_1_start} {w0_1_end} 5n 25p 25p 500n 1000n)
vw10_0 w_10<0> 0 PULSE({w1_0_start} {w1_0_end} 5n 25p 25p 500n 1000n)
vw10_1 w_10<1> 0 PULSE({w1_1_start} {w1_1_end} 5n 25p 25p 500n 1000n)
vw20_0 w_20<0> 0 PULSE({w2_0_start} {w2_0_end} 5n 25p 25p 500n 1000n)
vw20_1 w_20<1> 0 PULSE({w2_1_start} {w2_1_end} 5n 25p 25p 500n 1000n)

** Output loads - FO4
xinv_z0_0_0 z_0<0> z0_0_inv0 vdd vss INV
xinv_z0_0_1 z_0<0> z0_0_inv1 vdd vss INV
xinv_z0_0_2 z_0<0> z0_0_inv2 vdd vss INV
xinv_z0_0_3 z_0<0> z0_0_inv3 vdd vss INV
xinv_z0_1_0 z_0<1> z0_1_inv0 vdd vss INV
xinv_z0_1_1 z_0<1> z0_1_inv1 vdd vss INV
xinv_z0_1_2 z_0<1> z0_1_inv2 vdd vss INV
xinv_z0_1_3 z_0<1> z0_1_inv3 vdd vss INV
xinv_z0_2_0 z_0<2> z0_2_inv0 vdd vss INV
xinv_z0_2_1 z_0<2> z0_2_inv1 vdd vss INV
xinv_z0_2_2 z_0<2> z0_2_inv2 vdd vss INV
xinv_z0_2_3 z_0<2> z0_2_inv3 vdd vss INV

** Transient analysis - extended to 500ns for full settling
.TRAN 10p 500n

** Timing measurements
.MEAS TRAN t_input WHEN v(x_0<1>)={vdd/2} CROSS=1
.MEAS TRAN t_out0 WHEN v(z_0<0>)={vdd/2} CROSS=1
.MEAS TRAN t_out1 WHEN v(z_0<1>)={vdd/2} CROSS=1
.MEAS TRAN t_out2 WHEN v(z_0<2>)={vdd/2} CROSS=1

** .MEAS TRAN t_mult0_out0 WHEN v(mult0_out<0>)={vdd/2} CROSS=1
** .MEAS TRAN t_mult0_out1 WHEN v(mult0_out<1>)={vdd/2} CROSS=1
** 
** .MEAS TRAN t_mult1_out0 WHEN v(mult1_out<0>)={vdd/2} CROSS=1
** .MEAS TRAN t_mult1_out1 WHEN v(mult1_out<1>)={vdd/2} CROSS=1
** 
** .MEAS TRAN t_addr2_out0 WHEN v(addr2_out<0>)={vdd/2} CROSS=1
** .MEAS TRAN t_addr2_out1 WHEN v(addr2_out<1>)={vdd/2} CROSS=1
** .MEAS TRAN t_addr2_cout WHEN v(add2_cout)={vdd/2} CROSS=1
** 
** .MEAS TRAN t_addr3_out0 WHEN v(addr3_out<0>)={vdd/2} CROSS=1
** .MEAS TRAN t_addr3_out1 WHEN v(addr3_out<1>)={vdd/2} CROSS=1
** .MEAS TRAN t_addr3_out2 WHEN v(addr3_out<2>)={vdd/2} CROSS=1

.MEAS TRAN tpd_0 PARAM='t_out0-t_input'
.MEAS TRAN tpd_1 PARAM='t_out1-t_input'
.MEAS TRAN tpd_2 PARAM='t_out2-t_input'

** Output values - measure at 490ns (fully settled)
.MEAS TRAN v_z0_0_final FIND v(z_0<0>) AT=490n
.MEAS TRAN v_z0_1_final FIND v(z_0<1>) AT=490n
.MEAS TRAN v_z0_2_final FIND v(z_0<2>) AT=490n

** Power - measure over stable period
.MEAS TRAN power_avg AVG POWER FROM=250n TO=500n

.END
"""
    
    tb_path = Path(f'timing_test_{test_id}.sp')
    with open(tb_path, 'w') as f:
        f.write(testbench)
    
    return tb_path


meas_names = ['t_input', 't_out0', 't_out1', 't_out2', #'t_mult0_out0', 't_mult0_out1', 't_mult1_out0', 't_mult1_out1', 't_addr2_out0', 't_addr2_out1', 't_addr2_cout', 't_addr3_out0', 't_addr3_out1', 't_addr3_out2',*/
               'tpd_0', 'tpd_1', 'tpd_2', 'v_z0_0_final', 'v_z0_1_final', 'v_z0_2_final', 'power_avg', 'temper']

def parse_measurements(mt0_file, vdd=0.9):
    if not mt0_file.exists():
        return None
    
    with open(mt0_file, 'r') as f:
        lines = f.readlines()
    
    results = {}

    data_started = False
    line_num = 0
    for line in lines:
        if line.strip().startswith('alter#'):
            data_started = True
            continue  # Skip header lines
        if (data_started):
            values = line.split()
            for i in range(len(values)):
                 results[meas_names[i + line_num * 4]] = float(values[i]) if values[i] != 'failed' else None
            line_num += 1
            if line_num >= 3:
                break  # We only expect 3 lines of data

    # Convert voltages to output value
    if all(k in results for k in ['v_z0_0_final', 'v_z0_1_final', 'v_z0_2_final']):
        bit0 = 1 if results['v_z0_0_final'] > vdd/2 else 0
        bit1 = 1 if results['v_z0_1_final'] > vdd/2 else 0
        bit2 = 1 if results['v_z0_2_final'] > vdd/2 else 0
        results['output_value'] = bit2*4 + bit1*2 + bit0
        print(f"Output: {results['output_value']}")
    return results

# def parse_measurements(mt0_file, vdd=0.9):
#     """Parse HSPICE .mt0 file"""
#     if not mt0_file.exists():
#         return None
    
#     with open(mt0_file, 'r') as f:
#         lines = f.readlines()
    
#     results = {}
#     meas_names 
    
#     # Find the data section (starts after header lines)
#     data_started = False
#     for line in lines:
#         if line.strip().startswith('$DATA1'):
#             data_started = True
#             continue
        
#         if data_started:
#             # Look for measurement names
#             if 'tpd_0' in line or 'tpd_1' in line or 'tpd_2' in line or \
#                'v_z0_0_final' in line or 'v_z0_1_final' in line or 'v_z0_2_final' in line or \
#                'power_avg' in line:
#                 # This line contains measurement names
#                 meas_names = line.split()
#                 continue
            
#             # Look for measurement values (numeric line after names)
#             if line.strip() and line.strip()[0].isdigit() or line.strip().startswith('-') or 'failed' in line:
#                 values = line.split()
#                 # Map names to values
#                 if 'meas_names' in locals():
#                     for name, val in zip(meas_names, values):
#                         if val == 'failed':
#                             results[name] = None
#                         else:
#                             try:
#                                 results[name] = float(val)
#                             except:
#                                 pass
#                 break
    
#     # Convert voltages to output value
#     if all(k in results for k in ['v_z0_0_final', 'v_z0_1_final', 'v_z0_2_final']):
#         bit0 = 1 if results['v_z0_0_final'] > vdd/2 else 0
#         bit1 = 1 if results['v_z0_1_final'] > vdd/2 else 0
#         bit2 = 1 if results['v_z0_2_final'] > vdd/2 else 0
#         results['output_value'] = bit2*4 + bit1*2 + bit0

#     breakpoint()
    
#     return results

def run_test_case(tc, test_id, netlist='Neuron_submod.pex.netlist'):
    """Run a single test case"""
    tb_path = generate_timing_testbench(tc, test_id, netlist)
    
    try:
        result = subprocess.run(
            ['hspice', str(tb_path)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=300,
            text=True
        )
        
        if result.returncode != 0:
            return None
        
        mt0_path = tb_path.with_suffix('.mt0')
        return parse_measurements(mt0_path)
        
    except Exception as e:
        print(f"  Error: {e}")
        return None

def generate_exhaustive_tests():
        """
        Generate all 243 possible ternary test cases
        """
        test_cases = []
        test_id = 0
        
        print(f"\n{'='*70}")
        print(f"Generating Exhaustive Test Vectors")
        print(f"{'='*70}")
        print(f"Total combinations: 3^5 = 243 tests")
        print(f"{'='*70}\n")
        
        for x0, x1 in product([-1, 0, 1], repeat=2):
            for w00, w10, w20 in product([-1, 0, 1], repeat=3):
                test_cases.append({
                    'id': test_id,
                    'x0': x0,
                    'x1': x1,
                    'w0': w00,
                    'w1': w10,
                    'w2': w20,
                    'note': 'Auto Generated'
                })
                test_id += 1
        
        return test_cases

if __name__ == '__main__':
    import sys
    
    print("="*70)
    print("Ternary Neuron Timing Analysis - Multiple Test Cases")
    print("="*70)
    print()
    
    pex_netlist = 'Neuron_submod.pex.netlist'
    if not Path(pex_netlist).exists():
        print(f"❌ Error: {pex_netlist} not found!")
        sys.exit(1)
    
    test_cases = generate_exhaustive_tests()
    
    for tc in test_cases:
        tc['expected'] = golden_model(tc['x0'], tc['x1'], tc['w0'], tc['w1'], tc['w2'])
    
    print(f"Running {len(test_cases)} test cases with 25ps rise/fall times...")
    print()
    
    results = []
    tpd_max_global = 0
    for tc in test_cases:
        print("\n========================================\n")
        print(f"Test {tc['id']}: x0={tc['x0']:+d}, x1={tc['x1']:+d}, w0={tc['w0']:+d}, w1={tc['w1']:+d}, w2={tc['w2']:+d} → Expected={tc['expected']}")
        
        measurements = run_test_case(tc, tc['id'], pex_netlist)
        
        if measurements:
            actual = measurements.get('output_value', 'N/A')
            tpd_max = max([measurements.get('tpd_0', 0) or 0,
                          measurements.get('tpd_1', 0) or 0,
                          measurements.get('tpd_2', 0) or 0])
            tpd_max_global = max(tpd_max, tpd_max_global)
            
            passed = (actual == tc['expected'])
            print("expected value:\n")
            print(tc['expected'])
            print("\nactual value:\n")
            print(actual)
            status = "✅ PASS" if passed else "❌ FAIL"
            
            print(f"  Actual={actual}, tpd_max={tpd_max*1e9:.3f}ns, global tpd_max={tpd_max_global*1e9:.3f}ns, {status}")
            
            results.append({
                **tc,
                'actual': actual,
                'tpd_max': tpd_max,
                'power': measurements.get('power_avg'),
                'passed': passed
            })
        else:
            print(f"  ❌ Simulation failed")
            results.append({**tc, 'actual': 'FAIL', 'passed': False})

        print("\n========================================\n")
        
        print()
        if (tc['id'] != 46): cleanup_test_files(tc['id'])
    
    # Summary table
    print("="*70)
    print("Summary Table for Report")
    print("="*70)
    print()
    print(f"{'ID':<4} {'Inputs [x0,x1,w0,w1,w2]':<30} {'Exp':<4} {'Act':<4} {'Pass':<6} {'tpd(ns)':<10} {'Notes'}")
    print("-"*70)
    
    for r in results:
        inputs = f"[{r['x0']:+d},{r['x1']:+d},{r['w0']:+d},{r['w1']:+d},{r['w2']:+d}]"
        status = "Pass" if r['passed'] else "Fail"
        tpd = f"{r.get('tpd_max', 0)*1e9:.3f}" if r.get('tpd_max') else "N/A"
        
        print(f"{r['id']:<4} {inputs:<30} {r['expected']:<4} {r.get('output_value', 'N/A'):<4} {status:<6} {tpd:<10} {r['note']}")
    
    print()
    print("="*70)
    print()
    
    # Cleanup
    cleanup = input("Delete intermediate files? (y/n): ")
    if cleanup.lower() == 'y':
        import glob
        for f in glob.glob('timing_test_*.*'):
            try:
                Path(f).unlink()
            except:
                pass
        print("✅ Cleanup complete")
